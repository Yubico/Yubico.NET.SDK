// Copyright 2025 Yubico AB
//
// Licensed under the Apache License, Version 2.0 (the "License").
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Linq;
using System.Security.Cryptography;
using Yubico.Core.Iso7816;
using Yubico.YubiKey.Scp.Commands;
using Yubico.YubiKey.Scp.Helpers;


namespace Yubico.YubiKey.Scp
{
    /// <summary>
    /// Manages the state for Secure Channel Protocol 03 (SCP03) communication with a YubiKey.
    /// This class handles key agreement, authentication, and secure messaging between the host
    /// and the YubiKey using AES encryption and MAC operations. It supports the establishment
    /// of secure channels with PIV and other smart card applications by deriving session keys
    /// and performing mutual authentication.
    /// </summary>
    internal class Scp03State : ScpState
    {
        private readonly Memory<byte> _hostCryptogram;
        /// <summary>
        /// Creates a new SCP03 secure channel state using the provided session keys and host cryptogram.
        /// </summary>
        /// <param name="sessionKeys">The session keys generated by the SCP03 key agreement.</param>
        /// <param name="hostCryptogram">The host cryptogram used to authenticate the host and establish the secure channel.</param>
        public Scp03State(
            SessionKeys sessionKeys,
            ReadOnlyMemory<byte> hostCryptogram)
            : base(sessionKeys, new byte[16])
        {
            _hostCryptogram = hostCryptogram.ToArray();
        }

        /// <summary>
        /// Creates a new SCP03 secure channel state by performing key agreement and authentication with the YubiKey.
        /// </summary>
        /// <param name="pipeline">The APDU pipeline for communication with the YubiKey.</param>
        /// <param name="keyParameters">The key parameters required for SCP03 authentication.</param>
        /// <param name="hostChallenge">The host challenge to use for the key agreement.</param>
        /// <returns>A new instance of <see cref="Scp03State"/> configured for secure channel communication.</returns>
        /// <exception cref="ArgumentException">Thrown when host challenge or key parameters are invalid or incompatible.</exception>
        /// <exception cref="SecureChannelException">Thrown when secure channel establishment fails.</exception>
        internal static Scp03State CreateScpState(
            IApduTransform pipeline,
            Scp03KeyParameters keyParameters,
            ReadOnlyMemory<byte> hostChallenge)
        {
            if (hostChallenge.Length != 8)
            {
                throw new ArgumentException("Invalid size, must be 8 bytes", nameof(hostChallenge));
            }

            if (keyParameters is null)
            {
                throw new ArgumentNullException(nameof(keyParameters));
            }

            if (pipeline is null)
            {
                throw new ArgumentNullException(nameof(pipeline));
            }

            var (cardChallenge, cardCryptogram) = PerformInitializeUpdate(
                pipeline,
                keyParameters.KeyReference.VersionNumber,
                hostChallenge);

            var state = CreateScpState(keyParameters.StaticKeys, hostChallenge, cardChallenge, cardCryptogram);
            state.PerformExternalAuthenticate(pipeline);
            return state;
        }

        private static Scp03State CreateScpState(
            StaticKeys staticKeys,
            ReadOnlyMemory<byte> hostChallenge,
            ReadOnlyMemory<byte> cardChallenge,
            ReadOnlyMemory<byte> cardCryptogram)
        {
            // Derive session keys
            var sessionKeys = Derivation.DeriveSessionKeysFromStaticKeys(
                staticKeys,
                hostChallenge.Span,
                cardChallenge.Span);

            // Check supplied card cryptogram
            var calculatedCardCryptogram = Derivation.DeriveCryptogram(
                Derivation.DDC_CARD_CRYPTOGRAM,
                sessionKeys.MacKey.Span,
                hostChallenge.Span,
                cardChallenge.Span);

            if (!CryptographicOperations.FixedTimeEquals(cardCryptogram.Span, calculatedCardCryptogram.Span))
            {
                throw new SecureChannelException(ExceptionMessages.IncorrectCardCryptogram);
            }

            // Calculate host cryptogram
            var hostCryptogram = Derivation.DeriveCryptogram(
                Derivation.DDC_HOST_CRYPTOGRAM,
                sessionKeys.MacKey.Span,
                hostChallenge.Span,
                cardChallenge.Span);

            return new Scp03State(sessionKeys, hostCryptogram);
        }

        private static (ReadOnlyMemory<byte> cardChallenge, ReadOnlyMemory<byte> cardCryptogram) PerformInitializeUpdate(
            IApduTransform pipeline,
            byte keyVersionNumber,
            ReadOnlyMemory<byte> hostChallenge)
        {
            var initializeUpdateCommand = new InitializeUpdateCommand(
                keyVersionNumber, hostChallenge);

            var initializeUpdateResponseApdu = pipeline.Invoke(
                initializeUpdateCommand.CreateCommandApdu(),
                typeof(InitializeUpdateCommand),
                typeof(InitializeUpdateResponse));

            var initializeUpdateResponse = initializeUpdateCommand.CreateResponseForApdu(initializeUpdateResponseApdu);
            initializeUpdateResponse.ThrowIfFailed($"Error when performing {initializeUpdateCommand.GetType().Name}: {initializeUpdateResponse.StatusMessage}");

            byte[] cardChallenge = initializeUpdateResponse.CardChallenge.ToArray();
            byte[] cardCryptogram = initializeUpdateResponse.CardCryptogram.ToArray();

            return (cardChallenge, cardCryptogram);
        }

        private void PerformExternalAuthenticate(IApduTransform pipeline)
        {
            // Create a MAC:ed APDU
            var (commandExtAuth, newMacChainingValue) = GetMacedExternalAuthenticateCommand(
                new ExternalAuthenticateCommand(_hostCryptogram));

            // Update the states MacChainingValue
            MacChainingValue = newMacChainingValue;

            // Send command
            var responseExtAuth = pipeline.Invoke(
                commandExtAuth.CreateCommandApdu(),
                typeof(ExternalAuthenticateCommand),
                typeof(ExternalAuthenticateResponse));

            commandExtAuth.CreateResponseForApdu(responseExtAuth).ThrowIfFailed();
        }

        private (ExternalAuthenticateCommand, ReadOnlyMemory<byte> macChainingValue) GetMacedExternalAuthenticateCommand(ExternalAuthenticateCommand externalAuthenticateCommand)
        {
            var (commandDataMaced, newMacChainingValue) = GetMacdCommandData(externalAuthenticateCommand.CreateCommandApdu());
            return (new ExternalAuthenticateCommand(commandDataMaced), newMacChainingValue);
        }

        private (ReadOnlyMemory<byte> commandDataMaced, ReadOnlyMemory<byte> newMacChainingValue) GetMacdCommandData(CommandApdu commandApdu)
        {
            var (macedApdu, newMacChainingValue) = MacApdu(
                commandApdu,
                SessionKeys.MacKey.Span,
                MacChainingValue.Span
                );

            return (macedApdu.Data, newMacChainingValue);
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                CryptographicOperations.ZeroMemory(_hostCryptogram.Span);
            }

            base.Dispose(disposing);
        }
    }
}
