// Copyright 2021 Yubico AB
//
// Licensed under the Apache License, Version 2.0 (the "License").
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using Yubico.YubiKey.Piv.Commands;
using Yubico.YubiKey.Scp03;
using Yubico.YubiKey.TestUtilities;
using Xunit;

namespace Yubico.YubiKey.Piv
{
    public class GenerateTests
    {
        [Fact]
        public void SimpleGenerate()
        {
            IYubiKeyDevice testDevice = IntegrationTestDeviceEnumeration.GetTestDevice(
                Transport.SmartCard, FirmwareVersion.V5_3_0);
            Assert.True(testDevice.AvailableUsbCapabilities.HasFlag(YubiKeyCapabilities.Piv));

            var scp03Keys = new StaticKeys();

            using (var pivSession = new PivSession(testDevice, scp03Keys))
            {
                var collectorObj = new Simple39KeyCollector();
                pivSession.KeyCollector = collectorObj.Simple39KeyCollectorDelegate;

                PivPublicKey publicKey = pivSession.GenerateKeyPair(
                    PivSlot.Retired12, PivAlgorithm.Rsa2048);

                Assert.Equal(PivAlgorithm.Rsa2048, publicKey.Algorithm);
            }
        }

        [Fact]
        public void GenerateAndSign()
        {
            PivAlgorithm algorithm = PivAlgorithm.Rsa2048;

            IYubiKeyDevice testDevice = IntegrationTestDeviceEnumeration.GetTestDevice(
                Transport.SmartCard, FirmwareVersion.V5_3_0);

            Assert.True(testDevice.AvailableUsbCapabilities.HasFlag(YubiKeyCapabilities.Piv));

            Assert.True(testDevice is YubiKeyDevice);
            if (testDevice is YubiKeyDevice device)
            {
#pragma warning disable CS0618 // Specifically testing this feature
                testDevice = device.WithScp03(new StaticKeys());
#pragma warning restore CS0618
            }

            bool isValid = DoGenerate(
                testDevice, 0x86, algorithm, PivPinPolicy.Once, PivTouchPolicy.Never);
            Assert.True(isValid);

            isValid = DoSignNoPin(testDevice, 0x86, algorithm);
            Assert.False(isValid);

            isValid = DoSignWithPin(testDevice, 0x86, algorithm);
            Assert.True(isValid);
        }

        private static bool DoGenerate(
            IYubiKeyDevice yubiKey, byte slotNumber, PivAlgorithm algorithm,
            PivPinPolicy pinPolicy, PivTouchPolicy touchPolicy)
        {
            using (var pivSession = new PivSession(yubiKey))
            {
                var collectorObj = new Simple39KeyCollector();
                pivSession.KeyCollector = collectorObj.Simple39KeyCollectorDelegate;

                PivPublicKey publicKey = pivSession.GenerateKeyPair(
                    slotNumber, algorithm, pinPolicy, touchPolicy);
            }

            return true;
        }

        private static bool DoSignNoPin(
            IYubiKeyDevice yubiKey, byte slotNumber, PivAlgorithm algorithm)
        {
            using (var pivSession = new PivSession(yubiKey))
            {
                byte[] digestData = GetDigestData(algorithm);
                var signCommand = new AuthenticateSignCommand(digestData, slotNumber);
                AuthenticateSignResponse signResponse = pivSession.Connection.SendCommand(signCommand);

                return signResponse.Status == ResponseStatus.Success;
            }
        }

        private static bool DoSignWithPin(
            IYubiKeyDevice yubiKey, byte slotNumber, PivAlgorithm algorithm)
        {
            using (var pivSession = new PivSession(yubiKey))
            {
                var collectorObj = new Simple39KeyCollector();
                pivSession.KeyCollector = collectorObj.Simple39KeyCollectorDelegate;
                if (pivSession.TryVerifyPin() == false)
                {
                    return false;
                }

                byte[] digestData = GetDigestData(algorithm);
                var signCommand = new AuthenticateSignCommand(digestData, slotNumber);
                AuthenticateSignResponse signResponse = pivSession.Connection.SendCommand(signCommand);
                if (signResponse.Status != ResponseStatus.Success)
                {
                    return false;
                }

                byte[] signature1 = signResponse.GetData();

                signCommand = new AuthenticateSignCommand(digestData, slotNumber);
                signResponse = pivSession.Connection.SendCommand(signCommand);
                if (signResponse.Status != ResponseStatus.Success)
                {
                    return false;
                }

                byte[] signature2 = signResponse.GetData();

                bool returnValue = signature1[10] == signature2[10];

                if ((algorithm == PivAlgorithm.EccP256) || (algorithm == PivAlgorithm.EccP384))
                {
                    returnValue = signature1[11] != signature2[11];
                }

                return returnValue;
            }
        }

        public static byte[] GetDigestData(PivAlgorithm algorithm) => algorithm switch
        {
            PivAlgorithm.Rsa2048 => new byte[] {
                0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x30,
                0x2f, 0x30, 0x0b, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x04, 0x20,
                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
            },

            PivAlgorithm.EccP256 => new byte[] {
                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
            },

            PivAlgorithm.EccP384 => new byte[] {
                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
                0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f
            },

            _ => new byte[] {
                0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x30,
                0x2f, 0x30, 0x0b, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x04, 0x20,
                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
            },
        };
    }
}
